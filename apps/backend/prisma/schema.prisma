// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Organization {
  id        String   @id @default(cuid())
  name      String
  ownerId   String   // Clerk user ID of the owner
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members   OrganizationMember[]
  roles     Role[]
  invites   Invite[]

  @@map("organizations")
}

model Role {
  id             String       @id @default(cuid())
  name           String
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  
  members        OrganizationMember[]
  invites        Invite[]
  
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@unique([organizationId, name])
  @@map("roles")
}

model OrganizationMember {
  id             String       @id @default(cuid())
  clerkUserId    String
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  
  roleId         String?
  role           Role?        @relation(fields: [roleId], references: [id])

  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@unique([organizationId, clerkUserId])
  @@map("organization_members")
}

model Invite {
  id             String       @id @default(cuid())
  token          String       @unique
  email          String
  status         String       @default("PENDING") // PENDING, ACCEPTED, EXPIRED
  expiresAt      DateTime

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  roleId         String?
  role           Role?        @relation(fields: [roleId], references: [id])

  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@map("invites")
}

// --- CRM Models ---

model User {
  id           String   @id @default(cuid())
  clerkId      String   @unique
  email        String   @unique
  name         String?
  eventContext String?  // "I plan weddings and corporate events"
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  projects            Project[]
  suppliers           Supplier[]
  supplierCategories  SupplierCategory[]
  gmailWatch          GmailWatch?
  backfillRuns        BackfillRun[]
  supplierCandidates  SupplierCandidate[]
  emailThreads        EmailThread[]
  statusConfigs       UserStatusConfig[]

  @@map("users")
}

model SupplierCategory {
  id          String   @id @default(cuid())
  name        String   // Display name, e.g. "Florist"
  slug        String   @unique // Lowercase normalized, e.g. "florist"
  description String?  // "Floral design, bouquets, arrangements..."
  isSystem    Boolean  @default(false) // True for seeded system categories
  
  // Nullable for system categories, set for user-created
  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Many-to-many with suppliers
  suppliers   SupplierToCategory[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("supplier_categories")
}

model Supplier {
  id               String   @id @default(cuid())
  name             String   // Business Name
  domain           String?  // null for personal domains (gmail, etc.)
  isPersonalDomain Boolean  @default(false) // true if this is a freelancer/individual
  notes            String?
  
  userId           String
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Many-to-many with categories
  categories         SupplierToCategory[]

  // Contacts at this company
  contacts           SupplierContact[]
  
  projectSuppliers   ProjectSupplier[]
  messages           Message[] // Aggregate messages for the supplier
  supplierCandidates SupplierCandidate[] // Candidates that became this supplier

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // For business domains, ensure unique per user
  @@unique([userId, domain])
  @@map("suppliers")
}

// Individual contact person at a Supplier (company)
model SupplierContact {
  id         String   @id @default(cuid())
  name       String   // Person's name
  email      String   // Their email address
  role       String?  // "Owner", "Sales Rep", "Account Manager", etc.
  isPrimary  Boolean  @default(false) // Primary contact for this supplier
  
  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  contactMethods ContactMethod[]

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([email]) // Email is globally unique
  @@index([supplierId])
  @@map("supplier_contacts")
}

// Junction table for Supplier <-> Category many-to-many
model SupplierToCategory {
  id          String   @id @default(cuid())
  
  supplierId  String
  supplier    Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  
  categoryId  String
  category    SupplierCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  
  isPrimary   Boolean  @default(false) // Main category for display purposes

  createdAt   DateTime @default(now())

  @@unique([supplierId, categoryId])
  @@map("supplier_to_categories")
}

model ContactMethod {
  id         String   @id @default(cuid())
  type       String   // "EMAIL", "PHONE", "WHATSAPP", etc.
  value      String   // actual email address or phone number
  label      String?  // e.g., "Main Office", "Emergency", "Bob's Cell"
  isPrimary  Boolean  @default(false)

  // Link to contact, not supplier directly
  contactId  String
  contact    SupplierContact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  messages   Message[] // Messages specifically via this method

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([value]) // Fast lookup for incoming webhooks
  @@map("contact_methods")
}

model Project {
  id          String   @id @default(cuid())
  name        String
  type        String
  date        DateTime?
  budget      Decimal? @db.Decimal(10, 2)
  description String?
  venue       String?
  guestCount  Int?
  
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  suppliers     ProjectSupplier[]
  messages      Message[]
  emailThreads  EmailThread[]   // Threads detected as related to this project
  statusProposals StatusProposal[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("projects")
}

model ProjectSupplier {
  id             String   @id @default(cuid())
  
  projectId      String
  project        Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  supplierId     String
  supplier       Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  role           String
  statusSlug     String   @default("needed") // Refers to SupplierStatus.slug
  quoteAmount    Decimal? @db.Decimal(10, 2)
  budgetAlloc    Decimal? @db.Decimal(10, 2) // Allocated budget for this vendor slot
  notes          String?
  
  // Status history for audit trail
  statusHistory  Json?    // [{slug, changedAt, changedBy, reason}]
  
  statusProposals StatusProposal[]

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([projectId, supplierId])
  @@map("project_suppliers")
}

// Email thread grouping for conversation context
model EmailThread {
  id              String   @id @default(cuid())
  gmailThreadId   String   @unique
  
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Thread-level metadata
  subject         String?            // Original thread subject
  participantEmails String[]         // All participants in thread
  messageCount    Int      @default(0)
  
  // Thread-level context detection
  detectedProjectId     String?
  detectedProject       Project? @relation(fields: [detectedProjectId], references: [id])
  detectedProjectConf   Float?       // Confidence in project detection
  detectedSupplierIds   String[]     // Suppliers involved
  
  // Status progression tracking
  statusHistory   Json?              // [{status, timestamp, messageId}]
  currentStatus   String?            // Latest detected status slug
  
  // Analysis metadata
  lastAnalyzedAt  DateTime?
  analysisVersion String?            // Track prompt version for re-analysis
  analysisJson    Json?              // Cached full analysis results
  
  messages        Message[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
  @@map("email_threads")
}

model Message {
  id              String   @id @default(cuid())
  
  // Gmail identifiers (crucial for threading)
  gmailMessageId  String?  @unique
  gmailThreadId   String?
  
  // Thread relationship
  threadId        String?
  thread          EmailThread? @relation(fields: [threadId], references: [id], onDelete: SetNull)
  
  // Core fields
  content         String   @db.Text
  contentClean    String?  @db.Text  // Stripped of signatures/quotes
  subject         String?
  direction       String   // "INBOUND", "OUTBOUND"
  channel         String   @default("EMAIL") // "EMAIL", "WHATSAPP", etc.
  sentAt          DateTime @default(now())
  externalId      String?  // External Message ID (legacy)
  
  // Quoted content detection
  hasQuotedContent Boolean @default(false)
  quotedMessageId  String?  // Reference to message being replied to
  
  // Relationships
  userId          String?
  
  projectId       String?
  project         Project? @relation(fields: [projectId], references: [id])
  projectLinkConfidence Float?  // 0-1, null = manual link
  projectLinkMethod     String? // "THREAD_CONTEXT" | "MESSAGE_CONTENT" | "USER" | "AUTO"
  
  supplierId      String?
  supplier        Supplier? @relation(fields: [supplierId], references: [id])
  
  contactMethodId String?
  contactMethod   ContactMethod? @relation(fields: [contactMethodId], references: [id])
  
  // Status detection (per-message contribution)
  detectedStatusSlug    String?  // What status this message suggests
  statusConfidence      Float?   // Confidence in status detection
  statusSignals         String[] // What signals were matched
  
  // Analysis cache
  analysisJson    Json?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([gmailThreadId])
  @@index([userId])
  @@map("messages")
}

model GmailWatch {
  id           String   @id @default(cuid())
  userId       String   @unique
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailAddress String
  historyId    String
  expiration   BigInt
  updatedAt    DateTime @updatedAt

  @@map("gmail_watches")
}

// --- Supplier Status Pipeline ---

model SupplierStatus {
  id          String   @id @default(cuid())
  slug        String   @unique  // "rfq-sent", "quote-received"
  name        String            // "RFQ Sent", "Quote Received"
  description String?           // Clear definition of what this status means
  order       Int               // Pipeline ordering (1-10)
  color       String?           // For UI badges, e.g. "#10B981"
  isSystem    Boolean  @default(true)  // Predefined vs custom
  
  // Detection signals for AI/rule matching
  inboundSignals   String[]  // Signals in messages FROM supplier
  outboundSignals  String[]  // Signals in messages TO supplier
  threadPatterns   String[]  // Thread-level patterns, e.g. "first outbound asking"
  excludePatterns  String[]  // Patterns that EXCLUDE this status (e.g., "will send quote" excludes quote-received)
  
  userConfigs      UserStatusConfig[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("supplier_statuses")
}

model UserStatusConfig {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  statusId  String
  status    SupplierStatus @relation(fields: [statusId], references: [id], onDelete: Cascade)
  isEnabled Boolean  @default(true)  // User can disable statuses they don't use

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, statusId])
  @@map("user_status_configs")
}

model StatusProposal {
  id              String   @id @default(cuid())
  
  projectSupplierId String
  projectSupplier   ProjectSupplier @relation(fields: [projectSupplierId], references: [id], onDelete: Cascade)
  
  // Optional link to project for easier querying
  projectId       String?
  project         Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  // Which message triggered this proposal
  messageId       String?
  threadId        String?
  
  fromStatus      String?  // Current status slug (null if first detection)
  toStatus        String   // Proposed status slug
  confidence      Float    // 0-1
  
  // Evidence
  matchedSignals  String[]
  reasoning       String?  // AI-generated explanation
  
  // Resolution
  status          String   @default("PENDING")  // PENDING, ACCEPTED, REJECTED, EXPIRED
  resolvedAt      DateTime?
  resolvedBy      String?  // userId
  
  createdAt       DateTime @default(now())
  expiresAt       DateTime // Auto-expire after 7 days

  @@index([projectSupplierId])
  @@index([status])
  @@map("status_proposals")
}

// --- Inbox Backfill Models ---

model BackfillRun {
  id                 String   @id @default(cuid())
  userId             String
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  status             String   @default("PENDING") // PENDING, RUNNING, COMPLETED, FAILED, CANCELLED
  timeframeMonths    Int      @default(6)
  gmailQuery         String   // e.g. "in:sent newer_than:6m"
  nextPageToken      String?  // For resuming Gmail pagination
  eventContext       String?  // User's event types for AI context
  
  // Discovery progress counters
  scannedMessages    Int      @default(0)
  discoveredContacts Int      @default(0)
  createdCandidates  Int      @default(0)
  errorsCount        Int      @default(0)

  // Enrichment phase tracking
  enrichmentStatus   String   @default("PENDING") // PENDING, RUNNING, COMPLETED
  enrichedCount      Int      @default(0)
  autoImportedCount  Int      @default(0)

  startedAt          DateTime?
  completedAt        DateTime?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@map("backfill_runs")
}

model SupplierCandidate {
  id                    String   @id @default(cuid())
  userId                String
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  email                 String   // Normalized email
  domain                String   // Domain extracted from email
  displayName           String?  // Best-effort display name from email header

  source                String   @default("GMAIL_SENT") // GMAIL_SENT, MANUAL, etc.
  status                String   @default("NEW") // NEW, ACCEPTED, DISMISSED, MERGED

  // Stats from scan
  messageCount          Int      @default(1)
  firstSeenAt           DateTime @default(now())
  lastSeenAt            DateTime @default(now())

  // Email context for AI enrichment
  // Array of: {subject: string, content: string, date: string}
  emailContextJson      Json?    // Cleaned email snippets (up to 5)

  // AI suggestions
  suggestedSupplierName String?
  suggestedContactName  String?  // Person's name if different from company
  suggestedRole         String?  // "Owner", "Sales", etc.
  suggestedCategories   String[] // Array of category slugs, e.g. ["photography", "videography"]
  primaryCategory       String?  // Main category slug for display
  confidence            Float?   // 0-1
  isRelevant            Boolean? // AI determined if this is a relevant supplier
  enrichmentJson        Json?    // Raw enrichment result

  // If accepted, link to created supplier and contact
  supplierId            String?
  supplier              Supplier? @relation(fields: [supplierId], references: [id])

  enrichmentRuns        EnrichmentRun[]

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([userId, email])
  @@index([userId, status])
  @@index([domain])
  @@map("supplier_candidates")
}

// --- A/B Testing Infrastructure for Enrichment ---

model EnrichmentExperiment {
  id            String   @id @default(cuid())
  name          String   // "GPT-5 vs GPT-4o - v2 prompt with snippets"
  description   String?  // Details about what's being tested
  promptVersion String   // "v1", "v2-with-snippets", "v3-400-char"
  modelConfig   Json     // {model: "gpt-5-mini", maxTokens: 2000, ...}
  isActive      Boolean  @default(true)
  
  runs          EnrichmentRun[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("enrichment_experiments")
}

model EnrichmentRun {
  id            String   @id @default(cuid())
  
  experimentId  String
  experiment    EnrichmentExperiment @relation(fields: [experimentId], references: [id], onDelete: Cascade)
  
  candidateId   String
  candidate     SupplierCandidate @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  
  // Model info
  model         String   // "gpt-5-mini", "gpt-4o-mini"
  promptVersion String   // Version of the prompt used
  
  // Metrics
  inputTokens   Int
  outputTokens  Int
  latencyMs     Int
  cost          Float    // Calculated from tokens
  
  // Full audit trail
  rawPrompt     String   @db.Text
  rawResponse   String   @db.Text
  
  // Parsed result
  resultJson    Json?    // Parsed response: {suggestedName, categories, etc.}
  
  feedback      EnrichmentFeedback?
  
  createdAt     DateTime @default(now())

  @@index([experimentId])
  @@index([candidateId])
  @@map("enrichment_runs")
}

model EnrichmentFeedback {
  id                  String   @id @default(cuid())
  
  runId               String   @unique
  run                 EnrichmentRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  
  isCorrect           Boolean  // Was the AI's classification correct?
  correctedName       String?  // If name was wrong
  correctedCategories Json?    // If categories were wrong: ["photography", "videography"]
  correctedRelevance  Boolean? // If relevance was wrong
  notes               String?  // Freeform notes from reviewer
  
  feedbackBy          String?  // userId who provided feedback
  feedbackAt          DateTime @default(now())

  @@map("enrichment_feedback")
}

// Global domain info cache (shared across users for efficiency)
model DomainInfo {
  id            String   @id @default(cuid())
  domain        String   @unique // e.g. "floristshop.com"
  
  // Scraped/enriched data
  title         String?
  description   String?
  industry      String?
  services      String?
  
  // Enrichment metadata
  lastFetchedAt DateTime?
  fetchError    String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("domain_info")
}

// --- Status Detection Testing Models ---

// Versioned email test sets
model TestEmailSet {
  id              String   @id @default(cuid())
  name            String   @unique  // "v1-initial", "v2-more-edge-cases"
  description     String?
  
  // Stats
  totalCases      Int      @default(0)
  inboundCount    Int      @default(0)
  outboundCount   Int      @default(0)
  
  cases           TestCase[]
  runs            TestRun[]
  
  createdAt       DateTime @default(now())

  @@map("test_email_sets")
}

// Supplier personas for test generation
model TestPersona {
  id              String   @id @default(cuid())
  name            String           // "Maria's Florals"
  companyName     String           // "Maria's Florals LLC"
  contactName     String           // "Maria Rodriguez"
  email           String           // "maria@mariasflorals.com"
  category        String           // "florist"
  
  // Personality traits
  communicationStyle String        // "formal", "casual", "terse", "verbose"
  reliability     String           // "reliable", "flaky", "aggressive"
  pricePoint      String           // "budget", "mid-range", "premium"
  
  testCases       TestCase[]
  createdAt       DateTime @default(now())

  @@map("test_personas")
}

// Individual test cases (emails)
model TestCase {
  id              String   @id @default(cuid())
  
  // Relationships
  emailSetId      String
  emailSet        TestEmailSet @relation(fields: [emailSetId], references: [id], onDelete: Cascade)
  personaId       String
  persona         TestPersona @relation(fields: [personaId], references: [id])
  
  // Email content
  subject         String
  body            String   @db.Text
  direction       String           // "INBOUND" | "OUTBOUND"
  
  // Thread context
  threadContext   Json?            // Previous messages array
  hasThreadContext Boolean @default(false)
  
  // Ground truth (v1 model - single status)
  expectedStatus  String
  previousStatus  String?          // Status before this email arrived (for progression context)

  // Ground truth (v2 model - primary/sub/actions)
  expectedPrimaryStatus  String?   // contacting, quoted, booked, completed, cancelled
  expectedSubStatus      String?   // Contextual substatus
  expectedActions        String[]  // Action flags like reply-needed, review-quote, etc.

  scenario        String           // "normal", "tricky", "followup", "edge"
  difficulty      Int              // 1-4
  
  // Metadata
  tags            String[]
  generationNotes String?  @db.Text // Why this email should be this status
  
  results         TestResult[]
  createdAt       DateTime @default(now())

  @@map("test_cases")
}

// Versioned prompts for A/B testing
model TestPrompt {
  id              String   @id @default(cuid())
  version         String   @unique  // "v1", "v2-dynamic", "v3-explicit"
  name            String           // "Dynamic Status Definitions"
  description     String?  @db.Text
  
  // The actual prompt content
  systemPrompt    String   @db.Text
  
  // Settings
  model           String   @default("gpt-4o-mini")
  maxTokens       Int      @default(1500)
  
  isActive        Boolean  @default(true)
  runs            TestRun[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("test_prompts")
}

// A test run execution
model TestRun {
  id              String   @id @default(cuid())
  
  // What we tested
  emailSetId      String
  emailSet        TestEmailSet @relation(fields: [emailSetId], references: [id])
  promptId        String
  prompt          TestPrompt @relation(fields: [promptId], references: [id])
  
  // Snapshot of settings at run time
  promptVersion   String
  model           String
  promptSnapshot  String   @db.Text  // Full prompt used (for reproducibility)
  
  // Aggregate stats (v1 model)
  totalCases      Int      @default(0)
  passed          Int      @default(0)
  failed          Int      @default(0)
  accuracy        Float    @default(0)

  // Aggregate stats (v2 model)
  primaryPassed      Int?
  primaryAccuracy    Float?
  subPassed          Int?
  subAccuracy        Float?
  actionsPassed      Int?
  actionsAccuracy    Float?

  // Performance
  avgLatencyMs    Float    @default(0)
  totalTokens     Int      @default(0)
  estimatedCost   Float    @default(0)
  
  // Status
  status          String   @default("PENDING") // PENDING, RUNNING, COMPLETED, FAILED
  startedAt       DateTime?
  completedAt     DateTime?
  errorMessage    String?
  
  results         TestResult[]
  createdAt       DateTime @default(now())

  @@map("test_runs")
}

// Individual test result
model TestResult {
  id              String   @id @default(cuid())

  runId           String
  run             TestRun  @relation(fields: [runId], references: [id], onDelete: Cascade)
  caseId          String
  case            TestCase @relation(fields: [caseId], references: [id])

  // Result (v1 model)
  passed          Boolean
  expectedStatus  String
  detectedStatus  String?
  confidence      Float?
  reasoning       String?  @db.Text

  // Result (v2 model - primary/sub/actions)
  detectedPrimaryStatus  String?
  detectedSubStatus      String?
  detectedActions        String[]
  primaryPassed          Boolean?
  subPassed              Boolean?
  actionsPassed          Boolean?

  // Debug info
  rawResponse     String?  @db.Text
  latencyMs       Int      @default(0)
  tokens          Int?

  createdAt       DateTime @default(now())

  @@map("test_results")
}
